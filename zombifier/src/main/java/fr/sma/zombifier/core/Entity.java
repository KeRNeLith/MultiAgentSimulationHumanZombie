package fr.sma.zombifier.core;

import fr.sma.zombifier.behavior.BaseBehaviour;
import fr.sma.zombifier.event.Event;
import fr.sma.zombifier.utils.Globals;
import fr.sma.zombifier.utils.MersenneTwisterFast;
import fr.sma.zombifier.utils.Pair;
import fr.sma.zombifier.world.Platform;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * The class is the base class for all entities. This class should be subclass to make sense.
 * This is an abstract class.
 * 
 * @author Alexandre Rab√©rin - Adrien Pierreval
 */
public abstract class Entity
{
    /** Seed used to initialize all random generator for each entity. */
    private static long m_baseSeed = 1234;
 
    /** Class attribute to determine the ID of each constructed entity. */
    private static int m_nextId = 1;
    /** ID of the entity. */
    protected int m_id;
    
    /** Random generator of the entity. */
    protected final MersenneTwisterFast m_mt;
    
    /** Current behaviour of the entity. */
    protected BaseBehaviour m_behaviour;

    /** Platform on which the entity is on. */
    protected Platform m_position;
    /** Direction in which the entity is watching. */
    protected Pair<Integer, Integer> m_direction;
    /** Is the entity active ? */
    protected boolean m_active;
    
    /**
     * Constructor.
     * @param p Platform on which the entity begin the simulation.
     * @param directionX Watching direction on X axis.
     * @param directionY Watching direction on Y axis.
     */
    public Entity(final Platform p, final int directionX, final int directionY)
    {
        this.m_id = m_nextId++;
        this.m_position = p;
        this.m_direction = new Pair<>(directionX, directionY);
        this.m_active = true;
        
        // Initialize Random generator
        if (Globals.USE_RANDOM_SEED)
            this.m_mt = new MersenneTwisterFast(System.currentTimeMillis());
        else
            this.m_mt = new MersenneTwisterFast(m_baseSeed++);
        
        this.m_behaviour = null;
    }

    /**
     * Main method of an entity. Manage all actions that are allowed to be done at a given time t.
     * @return List of events generated by the life cycle of the entity.
     */
    public List<Event> live()
    {
        // Analyse the environment to make a decision.
        m_behaviour.analyze();

        // Move the entity
        List<Event> eventList = m_behaviour.react();
        
        // Affect the behaviour with the behaviour that comes next
        m_behaviour = m_behaviour.next();

        return eventList;
    }

    /**
     * Get the position of an entity
     * @return The platform on which the entity is
     */
    public Platform getPosition() 
    { 
        return m_position;  
    }

    /**
     * Get the direction the entity is looking at
     * @return A pair of integer containing the direction
     */
    public Pair<Integer, Integer> getDirection() 
    { 
        return m_direction;   
    }

    /**
     * Return the number of moving to do to go to p
     * @param p Platform to go
     * @return Number of moving to do to go at p.
     */
    public int getDistance(Platform p) 
    {
        return m_position.getDistance(p);
    }

    /**
     * Move the entity in a random position.
     * @return The new position of the entity.
     */
    public Platform randomMove()
    {
        int random;
        ArrayList<Platform> possibleLocations = m_position.getAvailableLocations();

        Collections.shuffle(possibleLocations, m_mt);

        // Find a place
        if(!possibleLocations.isEmpty()) {                                   // The entity is stuck
            random = m_mt.nextInt(possibleLocations.size());
            m_position = possibleLocations.get(random);
        }

        // Define a random direction
        random = m_mt.nextInt(4);

        switch(random)
        {
            case(0):
                m_direction.setFirst(0);
                m_direction.setSecond(1);
                break;
            case(1):
                m_direction.setFirst(0);
                m_direction.setSecond(-1);
                break;
            case(2):
                m_direction.setFirst(1);
                m_direction.setSecond(0);
                break;
            case(3):
                m_direction.setFirst(-1);
                m_direction.setSecond(0);
                break;
            default:
                // Do nothing
        }

        return m_position;
    }

    /**
     * Move the entity in a direction of a platform.
     * @param dest Platform where the entity should move.
     * @return Platform where the entity stand at the end of the moving.
     */
    public Platform moveTo(Platform dest) 
    {
        int min = Integer.MAX_VALUE;
        Platform currentPosition = m_position;
        ArrayList<Platform> possibilities = currentPosition.getAvailableLocations();

        Collections.shuffle(possibilities, m_mt);

        // If there is possibilities
        if(possibilities.size() > 0) {
            // Get the further platform
            for(Platform p : possibilities) {
                int distance = p.getDistance(dest);
                if(p.getEntity() == null && distance < min) {
                    min = distance;
                    m_position = p;
                }
            }
        }

        // If there is no possibilities, the entity stays at place

        return m_position;
    }

    /**
     * Attack the target entity in parameter.
     * @param e Target entity.
     * @return True if the attack succeed, otherwise false.
     */
    public abstract boolean attack(Entity e);

    /**
     * Return if the entity is active or not.
     * @return True if it is, Otherwise false.
     */
    public boolean isActive() 
    { 
        return m_active; 
    }

    /**
     * Disable an entity. It is equivalent to kill it.
     */
    public void disable() 
    { 
        m_active = false; 
    }
}
